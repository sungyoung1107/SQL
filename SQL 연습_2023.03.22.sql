/*
 * CREATE TABLE
 */

CREATE TABLE DEPT_TEMP
AS SELECT * FROM DEPT;

SELECT * FROM DEPT_TEMP ;

INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
VALUES (50, 'DATABASE', 'SEOUL');

INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
VALUES (70, 'WEB', NULL);

INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
VALUES (70, 'WEB', NULL);

INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
VALUES (80, 'MOBILE','');

INSERT INTO DEPT_TEMP (DEPTNO, LOC)
VALUES (70, 'INCHEON');

SELECT * FROM DEPT_TEMP;

DESC DEPT_TEMP;

/*
컬럼 값만 복사해서 새로운 테이블을 생성 
WHERE 1<>1
*/
CREATE TABLE EMP_TEMP AS SELECT * FROM EMP WHERE 1<>1;

COMMIT;

SELECT * FROM EMP_TEMP;

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (9999, '홍길동', 'PRESIDENT', NULL, '2001/01/01', 5000, 1000, 10);

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (9999, '홍길동', 'PRESIDENT', NULL, TO_DATE('2001/01/01','YYYY/MM/DD'), 5000, 1000, 10);

SELECT * FROM EMP_TEMP;

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (2111, '이순신', 'MANAGER', 9999, TO_DATE('07/01/2001','DD/MM/YYYY'), 4000, NULL, 20);

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (3111, '심청이', 'MANAGER', 9999, SYSDATE, 4000, NULL, 30);

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO 
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND S.GRADE = 1;

SELECT * FROM EMP_TEMP;

CREATE TABLE DEPT_TEMP2
AS SELECT * FROM DEPT;

SELECT * FROM DEPT_TEMP2;

/*
 * 업데이트는 WHERE 절이 필수이다 
 */

UPDATE DEPT_TEMP2
SET LOC = 'SEOUL';

SELECT * FROM DEPT_TEMP2;

ROLLBACK;

UPDATE DEPT_TEMP2 SET LOC = 'NEW YORK' WHERE DEPTNO = 10;
UPDATE DEPT_TEMP2 SET LOC = 'DALLAS' WHERE DEPTNO = 20;
UPDATE DEPT_TEMP2 SET LOC = 'CHICAGO' WHERE DEPTNO = 30;
UPDATE DEPT_TEMP2 SET LOC = 'BOSTON' WHERE DEPTNO = 40;

SELECT * FROM DEPT_TEMP2;

UPDATE DEPT_TEMP2
SET (DNAME, LOC) = (SELECT DNAME, LOC FROM DEPT WHERE DEPTNO = 40)
WHERE DEPTNO = 40;

SELECT * FROM DEPT_TEMP2;

COMMIT; -- 원복불가 -- 사장결제 끝

-- 서브쿼리 사용
-- 조심@@@!!!
UPDATE DEPT_TEMP2
SET DNAME = (SELECT DNAME FROM DEPT WHERE DEPTNO = 40),
LOC = (SELECT LOC FROM DEPT WHERE DEPT40 = 40)

UPDATE DEPT_TEMP2
SET LOC = 'SEOUL'
WHERE DEPTNO = (SELECT DEPTNO FROM DEPT_TEMP2 WHERE DNAME = 'OPERATIONS');

SELECT * FROM DEPT_TEMP2;

ROLLBACK;

/* 
 * DELETE
 */

CREATE TABLE EMP_TEMP2
AS SELECT * FROM EMP;

SELECT * FROM EMP_TEMP2;

DELETE FROM EMP_TEMP2 
WHERE JOB = 'MANAGER';

SELECT * FROM EMP_TEMP2;

ROLLBACK;
COMMIT;

DELETE FROM EMP_TEMP2
WHERE EMPNO IN (SELECT E.EMPNO
FROM EMP_TEMP2 E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
AND S.GRADE = 3
AND DEPTNO = 30);

SELECT * FROM EMP_TEMP2;

DELETE FROM EMP_TEMP2;

SELECT * FROM EMP_TEMP2;

/*
 * CREATE문 
 * 
 * 
 * */
CREATE TABLE EMP_NEW (
	EMPNO NUMBER(4),
	ENAME VARCHAR2(10),
	JOB VARCHAR2(9),
	MGR NUMBER(4),
	HIREDATE DATE,
	SAL NUMBER(7,2),
	COMM NUMBER(7,2),
	DEPTNO NUMBER(2)
);

SELECT * FROM EMP_NEW;


SELECT * 
FROM EMP
WHERE ROWNUM <= 5;

ALTER TABLE EMP_NEW ADD HP VARCHAR2(20); 
SELECT * FROM EMP_NEW;

ALTER TABLE EMP_NEW RENAME COLUMN HP TO TEL;
SELECT * FROM EMP_NEW;

ALTER TABLE EMP_NEW MODIFY EMPNO NUMBER(5);
SELECT * FROM EMP_NEW;

ALTER TABLE EMP_NEW DROP COLUMN TEL;
SELECT * FROM EMP_NEW;

/* SEQUENCE 일련번호를 생성하여 테이블 관리를 편하게 하고자 함 */
CREATE SEQUENCE SEQ_DEPTSEQ -- 시퀀스 명
INCREMENT BY 1 -- 증가값(기본1)
START WITH 1 -- 시작값(기본2)
MAXVALUE 99 --최대값(NOMAXVALUE)
MINVALUE 1 --최소값(NOMINVALUE)
NOCYCLE NOCACHE; -- NOCYCLE 최대값에서 중단
-- NOCACHE 값 미리 생성 (기본 20)

CREATE TABLE DEPTSEQ AS SELECT * FROM DEPT; -- 테스트용

INSERT INTO DEPTSEQ (DEPTNO, DNAME, LOC)
VALUES (SEQ_DEPTSEQ.NEXTVAL, 'DATABASE', 'SEOUL');
INSERT INTO DEPTSEQ (DEPTNO, DNAME, LOC)
VALUES (SEQ_DEPTSEQ.NEXTVAL, 'WEB', 'BUSAN');
INSERT INTO DEPTSEQ (DEPTNO, DNAME, LOC)
VALUES (SEQ_DEPTSEQ.NEXTVAL, 'MOBILE', 'ILSAN');

SELECT * FROM DEPTSEQ;

/*
 * 제약 조건(CONSTRAINT) 지정
 * 
 * 테이블 생성할 때 테이블 컬럼별 제약 조건을 설정
 * 
 * 자주 사용하는 중요한 제약조건 유형
 * NOT NULL
 * UNIQUE
 * PK
 * FK
 * 
 */

CREATE TABLE login (	
	LOG_ID VARCHAR2(20) NOT NULL
	, LOG_PWD VARCHAR2(20) NOT NULL
	, TEL VARCHAR(2)
);

INSERT INTO LOGIN(LOG_ID, LOG_PWD, TEL) VALUES ('TEST01', '1234' ,'');

SELECT * FROM LOGIN;

ALTER TABLE LOGIN MODIFY TEL NOT NULL;
ALTER TABLE LOGIN MODIFY TEL VARCHAR(20);

/*
 * TEL 없는 고객이 발견되어 수소문 끝에 어렵게 전화번호를 구함
 */

SELECT * FROM LOGIN;

UPDATE LOGIN SET TEL = '01012345678' WHERE LOG_ID = 'TEST01';
ALTER TABLE LOGIN MODIFY TEL NOT NULL;

/*
 * 오라클 DBMS가 사용자를 위해 만들어 놓은 제약조건 실행값 테이블
 */

SELECT OWNER
, CONSTRAINT_NAME
, CONSTRAINT_TYPE
, TABLE_NAME
FROM USER_CONSTRAINTS;

-- 제약조건 이름을 TEL_NN 붙여 제약조건 변경
ALTER TABLE LOGIN MODIFY (TEL CONSTRAINT TEL_NN NOT NULL);

ALTER TABLE LOGIN DROP CONSTRAINT SYS_C007147;

-- 테이블에 있는 제약조건 확인
SELECT OWNER
, CONSTRAINT_NAME
, CONSTRAINT_TYPE
, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'LOGIN'; 

-- UNIQUE 키워드 사용
CREATE TABLE LOGIN_UNIQUE(
	LOGIN_ID VARCHAR2(20) UNIQUE,
	LOGIN_PWD VARCHAR2(20) NOT NULL,
	TEL VARCHAR2(20)
);

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS 
WHERE TABLE_NAME = 'LOGIN_UNIQUE';

INSERT INTO LOGIN_UNIQUE (LOGIN_ID, LOGIN_PWD, TEL)
VALUES ('TEST_ID_01', 'PWD01', '010-1234-5678');

INSERT INTO LOGIN_UNIQUE (LOGIN_ID, LOGIN_PWD, TEL)
VALUES ('TEST_ID_02', 'PWD01', '011-1234-5678');

INSERT INTO LOGIN_UNIQUE (LOGIN_ID, LOGIN_PWD, TEL)
VALUES (NULL, 'PWD01', '010-2345-6789');

SELECT * FROM LOGIN_UNIQUE;

-- UNIQUE 컬럼 중에서 NULL 값 채우기
UPDATE LOGIN_UNIQUE
SET LOGIN_ID = 'TEST_ID_NEW'
WHERE LOGIN_ID IS NULL;

-- 테이블명에 LOGIN이 포함된 제약 조건만 확인하기
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME LIKE 'LOGIN%';

-- 이미 생성된 테이블 컬럼에 UNIQUE 적용할 때 오류 발생
ALTER TABLE LOGIN_UNIQUE 
MODIFY(TEL UNIQUE);


/*
 * PRIMARY KEY
 * NOT NULL  + Unique + Index
 * 
 */
CREATE TABLE TABLE_PK (
	LOGIN_ID VARCHAR(20) PRIMARY KEY
	, LOGIN_PWD VARCHAR(20) NOT NULL
	, TEL VARCHAR(20)
);

-- 제약 조건 확인(USER_CONSTRAINT 테이블)
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS 
WHERE TABLE_NAME LIKE 'TABLE_PK%'

INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL) VALUES('PK_ID_01', 'PWD01', '010-1234-5678');
INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL) VALUES('PK_ID_01', 'PWD01', '010-2345-6789');

-- FOREIGN KEY
INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES
(9999, 'FK_TEST', 'CLERK', '7788', SYSDATE, 1200, NULL , 50);
-- FOREIGN KEY
INSERT INTO EMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES
(9999, 'FK_TEST', 'CLERK', '7788', SYSDATE, 1200, NULL , 50);

SELECT * FROM EMP_TEMP;

CREATE TABLE EMP_FK (
	EMPNO NUMBER(4) CONSTRAINT EMPFK_EMPNO_PK PRIMARY KEY
	, ENAME VARCHAR2(10)
	, JOB VARCHAR2(9)
	, MGR NUMBER(4)
	, HIREDATE DATE
	, SAL NUMBER(7,2)
	, COMM NUMBER(7,2)
	, DEPTNO NUMBER(2) CONSTRAINT EMPFK_DEPTNO_FK REFERENCES DEPT(DEPTNO) -- CONSTRAINT 외래키제약명 REFERENCES 테이블명(테이블컬럼)
);

/*
 * INDEX 빠른 검색을 위한 색인
 * 
 * 장점 : 순식간에 원하는 값을 찾아준다.
 * 단점 : 입력과 출력이 잦은 경우 인덱스가 설정된 테이블의 속도가 저하된다.
 */

-- 특정 직군에 해당하는 직원을 빠르게 찾기 위한 색인 지정
CREATE INDEX IDX_EMP_JOB
ON EMP(JOB);

-- 설정한 인덱스 리스트 출력
SELECT * FROM USER_INDEXES
WHERE TABLE_NAME IN ('EMP', 'DEPT');

/*
 * 뷰 : 가상의 임시 테이블처럼 사용하는 편리한 뷰
 */
CREATE VIEW VW_EMP10
AS (SELECT EMPNO, ENAME, JOB, DEPTNO
FROM EMP WHERE DEPTNO = 10);

CREATE VIEW VW_EMP20
AS (SELECT EMPNO, ENAME, JOB, DEPTNO
FROM EMP WHERE DEPTNO = 20);

-- VIEW들을 확인
SELECT * FROM USER_VIEWS;

SELECT VIEW_NAME, TEXT_LENGTH, TEXT FROM USER_VIEWS;

SELECT *
FROM USER_VIEWS
WHERE VIEW_NAME = 'VW_EMP20'; --테이블은 대문자로 표기

SELECT * FROM VW_EMP20;

/*
 * ROWNUM 사용
 * 컬럼에 ROWNUM 순번을 입력하여 사용할 수 있음 
 */

-- SAL DESC 순서와 무관하게 EMP 테이블에서 가져오는 순서로 순번을 출력
SELECT ROWNUM, E.*
FROM EMP E
ORDER BY SAL DESC;

-- 인라인 뷰, SAL DESC 순서에 따라 오름차순으로 ROWNUM 순번을 출력
SELECT ROWNUM, E.*
FROM (SELECT *
	FROM EMP E
	ORDER BY SAL DESC) E;
	
WITH E AS (SELECT * FROM EMP ORDER BY SAL DESC)
SELECT ROWNUM, E.*
FROM E;

SELECT ROWNUM, E.*
FROM (SELECT * FROM EMP E ORDER BY SAL DESC) E
WHERE ROWNUM <=5;

SELECT * FROM DICT;
SELECT * FROM DICTIONARY;

-- 사용자 테이블
SELECT TABLE_NAME
FROM USER_TABLES;

-- 모든 테이블
SELECT OWNER, TABLE_NAME
FROM ALL_TABLES;

-- DB 버전 정보
SELECT * FROM "V$VERSION";
SELECT * FROM DBA_TABLES;
SELECT * FROM DBA_USERS WHERE USERNAME='SCOTT';