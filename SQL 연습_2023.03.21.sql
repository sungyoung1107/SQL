/*
 * 레코드 그룹별 집계 : GROUP BY
 * 
 * 집계 조건 : HAVING
 * 
 */

SELECT SUM(E.SAL) AS sum_of_sal
, AVG(E.SAL) AS avg_of_sal
FROM EMP E;

SELECT * FROM EMP;

SELECT DISTINCT E.EMPNO
FROM EMP E;

SELECT DISTINCT E.EMPNO, E.DEPTNO  
FROM EMP E;

SELECT SUM(DISTINCT E.SAL) AS SUM_OF_DISTINCT
, SUM(ALL E.SAL) AS SUM_OF_ALL
, SUM(E.SAL) AS NORMAL_SUM
FROM EMP E;

SELECT ENAME, SUM(SAL)
FROM EMP
GROUP BY ENAME;

SELECT SUM(COMM)
FROM EMP;

SELECT MAX(E.SAL) AS MAX_SAL
, MIN(E.SAL) AS MIN_SAL
FROM EMP E;

/*
 * COUNT 함수
 */
SELECT COUNT(EMPNO), COUNT(COMM)
FROM EMP;

SELECT COUNT(*) AS 건수
FROM EMP
WHERE DEPTNO = 30;

SELECT COUNT(e.ENAME)
FROM EMP e WHERE nvl(comm, 0) >= 0;

SELECT AVG(sal), '10' AS dno
FROM EMP
WHERE DEPTNO = 10

UNION ALL 

SELECT AVG(SAL), '20' AS dno
FROM EMP
WHERE DEPTNO = 20

UNION ALL 

SELECT AVG(SAL), '30' AS dno
FROM EMP
WHERE DEPTNO = 30

/*
 * GROUP BY 키워드 사용하여 스마트하게 집계
 */
SELECT DEPTNO, JOB
, COUNT(SAL)
, AVG(SAL + NVL(COMM, 0)) AS AVG_PAY
, MAX(SAL + NVL(COMM, 0)) AS MAX_PAY
, MIN(SAL + NVL(COMM, 0)) AS MIN_PAY
, SUM(SAL + NVL(COMM, 0)) AS SUM_PAY
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

/*
 * JOIN 키워드 : 테이블 정규화로 분할된 테이블 컬럼을 조인
 */
SELECT *
FROM EMP e, DEPT d
ORDER BY empno;

SELECT *
FROM EMP e, DEPT d
WHERE e.ENAME = 'MILLER'
ORDER BY e.EMPNO; 

SELECT DEPTNO -- 공통컬럼은 지정을 해줘야 한다.
FROM EMP E, DEPT D
WHERE E.ENAME = 'SMITH'
ORDER BY E.EMPNO 

/*
 * INNER JOIN 교집합 컬럼 연결
 */
SELECT *
FROM EMP, DEPT
WHERE DEPTNO = DEPTNO 
ORDER BY EMPNO;

SELECT E.EMPNO,
E.HIREDATE,
D.DNAME,
E.JOB,
E.SAL
FROM EMP E JOIN DEPT D 
ON E.DEPTNO = D.DEPTNO ;

SELECT E.EMPNO,
E.HIREDATE,
D.DNAME,
E.JOB,
E.SAL
FROM EMP E JOIN DEPT D
USING (DEPTNO);

/*
 * 자바, c/c++ 등 프로그램에서 sql 쿼리문 사용하는 경우
 * 쿼리문을 문자열로 사용 가능
 * 
 */
val_deptno ;  -- 사용자로부터 입력 받은 부서 번호

val_sql = "SELECT E.EMPNO,
E.HIREDATE,
D.DNAME,
E.JOB,
E.SAL
FROM EMP E JOIN DEPT D
USING (DEPTNO);"

SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.LOC 
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY D.DEPTNO, E.EMPNO;

SELECT E.EMPNO, E.HIREDATE, TO_CHAR(E.HIREDATE, 'YYYY/MM/DD') AS HIREDATE, E.ENAME, D.DEPTNO, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO 
ORDER BY D.DEPTNO ;

SELECT 
D.DNAME, E.JOB
, AVG(E.SAL) AS AVG_SAL
, SUM(E.SAL) AS SUM_SAL
, MAX(E.SAL) AS MAX_SAL
, MIN(E.SAL) AS MIN_SAL
, COUNT(E.SAL) AS CNT_SAL
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND E.SAL < 2000
GROUP BY D.DNAME, E.JOB;
--ORDER BY E.SAL DESC; SELECT 에 없는 값으로 에러

SELECT *
FROM EMP E, SALGRADE s 
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL ;

SELECT E.ENAME, E.DEPTNO, E.SAL, E.JOB
FROM EMP E, SALGRADE s 
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL ;


SELECT S.GRADE, COUNT(E.ENAME) AS 명수
FROM EMP E, SALGRADE s
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL 
GROUP BY S.GRADE
ORDER BY S.GRADE;

SELECT *
FROM SALGRADE;

SELECT e.ENAME, e.DEPTNO, e.JOB, s.GRADE, e.SAL
, s.LOSAL AS low_rng
, s.HISAL AS high_rng
FROM EMP e, SALGRADE s 
WHERE e.sal BETWEEN s.LOSAL AND s.HISAL ;

/*
 * join 형식은 salgrade 부여 후 grade로 그룹별 직원 수
 * */
SELECT s.grade, count(e.ename) AS emp_cnt
FROM emp e, SALGRADE s
WHERE e.sal BETWEEN s.LOSAL AND s.HISAL
GROUP BY s.GRADE
ORDER BY emp_cnt DESC;

SELECT 
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO ;

/*
 * Self-Join : 자기 자신의 릴레이션을 이용해서 테이블 컬럼을 조작
 *  
 */
SELECT e1.EMPNO AS 직원번호, e1.ENAME AS 직원이름,e2.EMPNO  AS 관리자번호, e2.ENAME AS 관리자이름 
FROM emp e1, emp e2 -- SELF-JOIN 목적으로 테이블 사용
WHERE e1.MGR = e2.EMPNO ;

SELECT * FROM emp;

/*
 * Left-Join : 왼쪽 테이블 값을 모두 가져오고
 * join 하는 테이블에서 해당 되는 값 일부만 가져오기
 * 
 */
--오라클
SELECT e1.EMPNO AS 직원번호, e1.ENAME AS 직원이름, e2.EMPNO  AS 관리자번호, e2.ENAME AS 관리자이름 
FROM emp e1, emp e2 -- SELF-JOIN 목적으로 테이블 사용
WHERE e1.MGR = e2.EMPNO(+) 
ORDER BY e1.empno;

-- 표준 SQL
SELECT e1.EMPNO AS 직원번호, e1.ENAME AS 직원이름, e2.EMPNO  AS 관리자번호, e2.ENAME AS 관리자이름 
FROM emp e1 LEFT OUTER JOIN emp e2 -- SELF-JOIN 목적으로 테이블 사용
ON e1.MGR = e2.EMPNO 
ORDER BY e1.empno;

/*
 * Right-Join : 왼쪽 테이블 값을 모두 가져오고
 * join 하는 테이블에서 해당 되는 값 일부만 가져오기
 * 
 */
-- 오라클
SELECT e1.EMPNO AS 직원번호, e1.ENAME AS 직원이름, e2.EMPNO  AS 관리자번호, e2.ENAME AS 관리자이름 
FROM emp e1, emp e2 -- SELF-JOIN 목적으로 테이블 사용
WHERE e1.MGR(+) = e2.EMPNO 
ORDER BY e1.empno;

-- 표준 SQL
SELECT e1.EMPNO AS 직원번호, e1.ENAME AS 직원이름, e2.EMPNO  AS 관리자번호, e2.ENAME AS 관리자이름 
FROM emp e1 RIGHT OUTER JOIN emp e2 -- SELF-JOIN 목적으로 테이블 사용
ON e1.MGR = e2.EMPNO 
ORDER BY e1.empno;

SELECT * FROM EMP;

/*
 * Full-Join : 왼쪽 테이블 값을 모두 가져오고
 * 양쪽 모두 포함 조인
 * 
 */
-- 오라클
SELECT e1.EMPNO AS 직원번호, e1.ENAME AS 직원이름, e2.EMPNO  AS 관리자번호, e2.ENAME AS 관리자이름 
FROM emp e1, emp e2 -- SELF-JOIN 목적으로 테이블 사용
WHERE e1.MGR(+) = e2.EMPNO(+) -- 오라클은 양측 조인 불가
ORDER BY e1.empno;

-- 표준 SQL
SELECT e1.EMPNO AS 직원번호, e1.ENAME AS 직원이름, e2.EMPNO  AS 관리자번호, e2.ENAME AS 관리자이름 
FROM emp e1 FULL OUTER JOIN  emp e2 -- SELF-JOIN 목적으로 테이블 사용
ON e1.MGR = e2.EMPNO 
ORDER BY e1.empno;

/*
 * EMP, DEPT, SALGRADE, SELF-JOIN EMP
 * 4개 테이블을 활용하여 값을 출력
 */

SELECT d.DEPTNO 
, d.DNAME
, e1.EMPNO 
, e1.ENAME
, e1.MGR
, e1.SAL
, s.LOSAL
, s.HISAL
, s.GRADE
, e2.EMPNO AS MGR_EMPNO
, e2.ENAME AS MGR_ENAME
FROM EMP e1
, DEPT d
, SALGRADE s 
, EMP e2
WHERE -- right JOIN
e1.DEPTNO(+) = d.DEPTNO 
AND e1.SAL BETWEEN s.LOSAL(+) AND s.HISAL(+)
AND e1.MGR = e2.EMPNO(+)
ORDER BY d.DEPTNO, e1.EMPNO ;

SELECT d.DEPTNO 
, d.DNAME
, e1.EMPNO 
, e1.ENAME
, e1.MGR
, e1.SAL
, s.LOSAL
, s.HISAL
, s.GRADE
, e2.EMPNO AS MGR_EMPNO
, e2.ENAME AS MGR_ENAME
FROM EMP e1 RIGHT OUTER JOIN DEPT d
ON e1.DEPTNO = d.DEPTNO
LEFT OUTER JOIN SALGRADE s
ON e1.SAL BETWEEN s.LOSAL AND s.HISAL
LEFT OUTER JOIN EMP e2
ON e1.MGR = e2.EMPNO 
ORDER BY d.DEPTNO, e1.EMPNO ;

SELECT * FROM DEPT;
SELECT * FROM EMP;
SELECT * FROM SALGRADE ;

SELECT ENAME, SAL
FROM EMP;

SELECT * FROM EMP
WHERE SAL > 2850;

/*
 * 단일행 서브쿼리 - 쿼리 안에 쿼리 문장을 사용
 * 
 * SELECT 쿼리의 결과는 --> 2차원 테이블에 불과
 * 
 */

-- 단일행 쿼리
SELECT ENAME, SAL
FROM EMP
WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME='BLAKE');

-- 단일행 쿼리
SELECT *
FROM EMP
WHERE HIREDATE < (SELECT HIREDATE FROM EMP WHERE ENAME='BLAKE');

-- 단일행 쿼리
SELECT e.EMPNO, e.ENAME, e.JOB, e.SAL, d.DEPTNO, d.DNAME, d.LOC
FROM EMP e, DEPT d
WHERE e.DEPTNO = d.DEPTNO
AND e.DEPTNO = 20
AND e.SAL > (SELECT AVG(SAL) FROM EMP);

-- 다중행 쿼리
SELECT e.DEPTNO, e.ENAME, e.SAL
FROM EMP e
WHERE e.DEPTNO IN (10, 30);

SELECT e.DEPTNO, e.ENAME, e.SAL
FROM EMP e JOIN (-- 부서별 최고 급여
SELECT DEPTNO, MAX(SAL) AS SAL
FROM EMP
GROUP BY DEPTNO) s ON e.DEPTNO = s.DEPTNO -- 중요함 
AND e.SAL = s.SAL;

SELECT e.DEPTNO, e.ENAME, e.SAL
FROM EMP e
WHERE e.SAL IN (SELECT MAX(SAL)
FROM EMP GROUP BY DEPTNO);

SELECT e.DEPTNO, e.ENAME, e.SAL
FROM EMP e
WHERE e.SAL IN (SELECT AVG(SAL)
FROM EMP GROUP BY DEPTNO);

SELECT e.DEPTNO, e.ENAME, e.SAL 
FROM EMP e
WHERE e.SAL = ANY(SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

SELECT *
FROM EMP 
WHERE SAL < ANY(SELECT SAL FROM EMP WHERE DEPTNO = 30)
ORDER BY SAL, EMPNO;

SELECT *
FROM EMP
WHERE SAL < ALL(SELECT SAL FROM EMP WHERE DEPTNO =30);

SELECT *
FROM EMP
WHERE SAL > ALL(SELECT SAL
FROM EMP
WHERE DEPTNO = 30) ;

SELECT SAL
FROM EMP
WHERE DEPTNO = 30;

-- 다중열 서브 쿼리
SELECT *
FROM EMP e WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL)
								FROM EMP
								GROUP BY DEPTNO);
							
SELECT E.EMPNO,
E.ENAME,
E.DEPTNO,
D.DNAME,
D.LOC
FROM (SELECT * FROM EMP WHERE DEPTNO = 10) E,
(SELECT * FROM DEPT) D
WHERE E.DEPTNO = D.DEPTNO ;

-- WITH 절 구문으로 간소화된 서브쿼리

WITH E AS (SELECT * FROM EMP WHERE DEPTNO = 10),
D AS (SELECT * FROM DEPT)
SELECT E.EMPNO
, E.ENAME
, E.DEPTNO
, D.DNAME
, D.LOC
FROM E, D
WHERE E.DEPTNO = D.DEPTNO ;

SELECT * FROM EMP;
-- 10: 5000
-- 20: 3000
-- 30: 2850