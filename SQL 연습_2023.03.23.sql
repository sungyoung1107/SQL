-- 데이터 입력, 갱신, 삭제 후 COMMIT 처리

CREATE TABLE DEPT_TCL AS SELECT * FROM DEPT; -- AS 데이터로 TABLE 생성

SELECT * FROM DEPT_TCL;

INSERT INTO DEPT_TCL VALUES (50, 'DATABASE', 'SEOUL');

UPDATE DEPT_TCL SET LOC = 'BUSAN' WHERE DEPTNO = 20;

DELETE FROM DEPT_TCL WHERE DEPTNO = 40;

SELECT * FROM DEPT_TCL;

COMMIT; -- 실행완료, 롤백불가

/*
 * LOCK 테스트
 * 동일한 계정으로 DBever, sqlplus에서해보기
 * 
 */
SELECT *
FROM DEPT_TCL; -- DBeaver 세션에서는 수정 결과가 잘 보임

COMMIT; -- 이제 SQL*PLUS 에서도 UPDATE 결과 조회 가능

/*
 * 튜닝 기초 : 자동차 튜닝과 같이 DB 처리 속도(우선)와 안정성 제고 목적의 경우가 대부분
 * 
 */

-- 튜닝 전
SELECT * FROM EMP 
WHERE SUBSTR(EMPNO, 1, 2) = 75 AND LENTH(EMPNO) = 4;

SELECT * FROM EMP WHERE ENAME || '' || JOB = 'WARD SALESMAN';

-- 튜닝 전
SELECT DISTINCT E.EMPNO, E.ENAME, M.DEPTNO
FROM EMP E JOIN DEPT M ON (E.EMPNO = M.DEPTNO);
-- 튜닝 후
SELECT DISTINCT E.EMPNO, E.NAME, E.DEPTNO
FROM EMP E JOIN DEPT M ON (E.DEPTNO = M.DEPTNO);

-- 튜닝 전
SELECT * FROM EMP WHERE DEPTNO = '10'
UNION
SELECT * FROM EMP WHERE DEPTNO = '20';
-- 튜닝 후(UNION은 중복 제거 비용 발생, 암묵적 변환 제거)
SELECT * FROM EMP WHERE DEPTNO = 10
UNION ALL
SELECT * FROM EMP WHERE DEPTNO = 20;

SELECT ENAME, EMPNO, SUM(SAL) FROM EMP
GROUP BY ENAME, EMPNO;

-- 튜닝 전
SELECT EMPNO, ENAME, SUM(SAL) AS SAL FROM EMP
GROUP BY EMPNO, ENAME;
-- 튜닝 후(인덱스 설정된 EMPNO 우선 순위 사용)
SELECT EMPNO, ENAME, SUM(SAL) AS SAL FROM EMP
GROUP BY EMPNO, ENAME;

-- 튜닝 전
SELECT EMPNO, ENAME FROM EMP
WHERE TO_CHAR(HIREDATE, 'YYYYMMDD') LIKE '1981%'
AND EMPNO > 7700;
-- 튜닝 후(LIKE 연산자보다는 부등호 값 비교)
SELECT EMPNO, ENAME FROM EMP
WHERE EXTRACT(YEAR FROM HIREDATE) = 1981 AND EMPNO > 7700;


--CREATE INDEX IDX_EMP_JOB
--ON EMP(JOB);

-- 집계 함수를 사용할 때 최대한 인덱스가 설정된 컬럼을 우선 사용
SELECT JOB, SUM(SAL) AS SUM_OF_SAL
FROM EMP 
GROUP BY JOB
ORDER BY IDX_EMP_JOB DESC;

-- 인덱스가 이미 있어서 확인하기
SELECT *
FROM USER_IND_COLUMNS
WHERE TABLE_NAME IN ('EMP');


SELECT *
FROM HR.EMPLOYEES ;

SELECT e.EMPLOYEE_ID
, e.JOB_ID
, e.MANAGER_ID
, e.DEPARTMENT_ID
FROM HR.EMPLOYEES e

/*
 * GROUP BY
 */

SELECT JOB, DEPTNO, FLOOR(AVG(SAL)) AS AVG_SAL
FROM EMP
GROUP BY JOB, DEPTNO 
ORDER BY JOB, DEPTNO;

SELECT EMPNO, ENAME, JOB, SAL
, DECODE(JOB, 'MANAGER', SAL*0.2,
'SALESMAN', SAL*0.3,
'ANALYST', SAL*0.05,
SAL*0.1) AS BONUS FROM EMP; 

SELECT EMPNO, ENAME, JOB, SAL,
CASE JOB WHEN 'MANAGER' THEN SAL*0.2
WHEN 'SALESMAN' THEN SAL*0.3
WHEN 'ANALYST' THEN SAL*0.05
ELSE SAL*0.1 END AS BONUS
FROM EMP;

-- LISTAGG 함수
SELECT DEPTNO, ENAME
FROM EMP
GROUP BY DEPTNO, ENAME;

SELECT DEPTNO, LISTAGG(ENAME, ','), WITHIN GROUP(ORDER BY SAL DESC) AS ENAMES
FROM EMP
GROUP BY DEPTNO;

SELECT DEPTNO, JOB, MAX(SAL)
FROM EMP 
GROUP BY DEPTNO, JOB;

SELECT * FROM
(SELECT DEPTNO, JOB, SAL FROM EMP)
PIVOT(MAX(SAL) FOR DEPTNO IN (10,20,30))
ORDER BY JOB;

SELECT * FROM (SELECT JOB, DEPTNO, SAL FROM EMP)
PIVOT(MAX(SAL) FOR JOB IN ('CLERK' AS CLERK,
	'SALESMAN' AS SALESMAN,
	'PRESIDENT' AS PRESIDENT,
	'MANAGER' AS MANAGER,
	'ANALYST' AS ANALYST))

ORDER BY DEPTNO;

SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
FROM EMP e GROUP BY ROLLUP(DEPTNO, JOB);

SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
FROM EMP GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

SELECT DEPTNO, JOB, COUNT(*)
FROM EMP
GROUP BY DEPTNO, ROLLUP(JOB);

SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL),
GROUPING(DEPTNO), GROUPING(JOB)
FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

SELECT DEPTNO, JOB, COUNT(*), SUM(SAL), GROUPING(DEPTNO), GROUPING(JOB),
GROUPING_ID(DEPTNO, JOB)
FROM EMP 
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;